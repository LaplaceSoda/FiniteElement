%% 单跨梁的动力程序
%   考虑长为L、半径为r的一端简支一端刚固梁受分布力q、中点集中力F的动力响应
clc;clear all;

%% 初始化梁参数
% L - 梁的长度
% r - 梁的半径
% p - 梁的密度
% E - 杨氏模量
% A - 截面积
% I - 截面惯性矩 圆π*d^4/64
% c1 c2 - 瑞利阻尼系数
L = 10;
r1 = 0.02;
r2 = 0.01; 
p = 8000;
E = 2.1E11;
A1 = pi * r1 ^2;
I1 = pi * (2 * r1 )^4 / 64;
A2 = pi * r2 ^2;
I2 = pi * (2 * r2 )^4 / 64;
c1 = 0.35;
c2 = 0.0005;

%% 单元离散化及建立单元矩阵
% n - 单元个数
% h - 网格尺度
% X(i) - 节点位置
n = 20;
h = L/n;
X = 0:h:L;

% 建立单元刚度矩阵
%   ke - 单元刚度矩阵
k0 = E * 1 / h^3 .* [12   6*h    -12   6*h;...
                     6*h  4*h^2  -6*h  2*h^2;...
                     -12  -6*h   12    -6*h;...
                     6*h  2*h^2  -6*h  4*h^2];
ke1 = k0 * I1 ; 
ke2 = k0 * I2 ; 

% 建立单元质量矩阵
%   me - 单元刚度矩阵
m0 = p * 1 *h/420 .* [156    22*h    54     -13*h;...
                      22*h   4*h^2   13*h   -3*h^2;...
                      54     13*h    156    -22*h;...
                      -13*h  -3*h^2  -22*h  4*h^2];
me1 = m0 * A1 ; 
me2 = m0 * A2 ; 
                 
% 建立单元外力矩阵
%   N(x) - 形函数分量
%   q(x) - 分布力
%   f(x) - 集中力
%   r - 单元位移矩阵
syms x t;
q(x) = 0.15 + 0 * x ;
f(x) = 0 * x ; % 直接在总刚度矩阵中修正
N(x) = [1-3*x^2/h^2+2*x^3/h^3 x-2*x^2/h+x^3/h^2 3*x^2/h^2-2*x^3/h^3 -x^2/h+x^3/h^2];
r = int(N(x)'*q(x),x,0,h) * sin(2*t);  % q为时变量 但对路径积分与t无关 可在积分之后再写出，矩阵*符号函数 = 符号函数矩阵

%% 装配整体矩阵
% V - 整体位移矩阵
% M - 整体位移矩阵
% K - 整体刚度矩阵
% C - 整体阻尼矩阵
% R - 整体外力矩阵
V = zeros(2*(n+1),1);

M = zeros(2*(n+1));
for i = 1:2:2*(n/2+1)-3
    M(i:i+1,i:i+1) = M(i:i+1,i:i+1) + me1(1:2,1:2);
    M(i:i+1,i+2:i+3) = M(i:i+1,i+2:i+3) + me1(1:2,3:4);
    M(i+2:i+3,i:i+1) = M(i+2:i+3,i:i+1) + me1(3:4,1:2);
    M(i+2:i+3,i+2:i+3) = M(i+2:i+3,i+2:i+3) + me1(3:4,3:4);
end
for i = 2*(n/2+1)-1:2:2*(n+1)-3
    M(i:i+1,i:i+1) = M(i:i+1,i:i+1) + me2(1:2,1:2);
    M(i:i+1,i+2:i+3) = M(i:i+1,i+2:i+3) + me2(1:2,3:4);
    M(i+2:i+3,i:i+1) = M(i+2:i+3,i:i+1) + me2(3:4,1:2);
    M(i+2:i+3,i+2:i+3) = M(i+2:i+3,i+2:i+3) + me2(3:4,3:4);
end

K = zeros(2*(n+1));
for i = 1:2:2*(n/2+1)-3
    K(i:i+1,i:i+1) = K(i:i+1,i:i+1) + ke1(1:2,1:2);
    K(i:i+1,i+2:i+3) = K(i:i+1,i+2:i+3) + ke1(1:2,3:4);
    K(i+2:i+3,i:i+1) = K(i+2:i+3,i:i+1) + ke1(3:4,1:2);
    K(i+2:i+3,i+2:i+3) = K(i+2:i+3,i+2:i+3) + ke1(3:4,3:4);
end
for i = 2*(n/2+1)-1:2:2*(n+1)-3
    K(i:i+1,i:i+1) = K(i:i+1,i:i+1) + ke2(1:2,1:2);
    K(i:i+1,i+2:i+3) = K(i:i+1,i+2:i+3) + ke2(1:2,3:4);
    K(i+2:i+3,i:i+1) = K(i+2:i+3,i:i+1) + ke2(3:4,1:2);
    K(i+2:i+3,i+2:i+3) = K(i+2:i+3,i+2:i+3) + ke2(3:4,3:4);
end

C = c1 * M + c2 * K;

R = t * zeros(2*(n+1),1);
for i = 1:2:2*(n+1)-3
    R(i:i+1) = R(i:i+1)+ r(1:2);
    R(i+2:i+3) = R(i+2:i+3) + r(3:4);
end

f(t) = 0.2*cos(3*t);
R(2*(n/2+1)+1) = R(2*(n/2+1)+1) + f(t);

%% 设置边界条件
% 左端刚固 v = 0 转角 = 0
R(1) = 0;
K(1,1) = E.*K(1,1);
R(2) = 0;
K(2,2) = E.*K(2,2);
% 右端简支 v = 0 M = 0
R(2*(n+1)-1) = 0;
K(2*(n+1)-1,2*(n+1)-1) = E.*K(2*(n+1)-1,2*(n+1)-1);
R(2*(n+1)) = 0;

R(t) = R;      % R此时为函数矩阵,将其转换为时变函数

%% 中心差分法求解MCK微分方程
% T - 计算总时长
% dt - 时间步长
% m - 求解步数
% Tm(i) - 第i个时间步 = ( i - 1 ) dt 
% V - 挠度及转角
% V(:,j) - 第j个时间步的自由度向量
% V(i,j) - 第j个时间步的第i个自由度
% dV - 速度,V的导数
% a - 加速度,dV的导数
T = 30;
dt = 6e-6;
m = T / dt;
Tm = 0:dt:T;
V = zeros(2*(n+1),m+1);
dV = zeros(2*(n+1),m+1);
a = zeros(2*(n+1),m+1);

% 设置迭代初值
%   令V(0)=0,dV(0)=0,求解V(0)即为初值
%   由于K是稀疏阵，可用LU分解求解
%   对于中心差分法还需要求解V(-1)
[l,u]=lu(M);
a(:,1) = u\(l\double(R(0)));
a0 = 1/(dt)^2;
a1 = 1/2/(dt);
a2 = 2/(dt)^2;
V0 = (dt)^2/2 * a(:,1);
[l,u] = lu(a0 * M + a1 * C);
V(:,2) = u\(l\(double(R(0*dt)) - K*V(:,1) + M * a2 * V(:,1) - M * a0 * V0 + C * a1 * V0)); 

% 迭代求解V,dV,a
for i = 2:m
    ti = (i-1) *dt;
    % 考虑到矩阵接近奇异值，这里用LU分解求解
    % 由于不涉及速度和加速度，不对其进行迭代
    V(:,i+1) = u\(l\(double(R(ti)) - K*V(:,i)+ M * a2 * V(:,i) - M * a0 * V(:,i-1) + C * a1 * V(:,i-1)));
end

%% 数据处理与图像绘制

v = V(2*(1+n/2)+1,:);
subplot(2,1,1);
plot(Tm,v);
title('前30s的梁中点的时历');
xlabel('时间t/s')
ylabel('扰度ω/m');

% 用三点公式求Dv=v'',计算截面最大正应力
% Dv(i) - 第i+1个节点的挠度二阶导数值
% t(i) - 第i+1个节点的最大正应力
v = V(1:2:end,m/2+1);
Dv = zeros(n,1);
t = zeros(n,1);
for i = 1:n-1
    Dv(i) = Dv(i) + abs( v(i) - 2 * v(i+1) + v(i+2) ) / h^2;
    if i <= n/2+1
        t(i) = Dv(i)*E*r1; 
    else
        t(i) = Dv(i)*E*r2; 
    end
end
x = X(2:end);
subplot(2,1,2);
plot(x,t);
title('第15s的梁的应力分布');
xlabel('x/m');
ylabel('应力\tau/Pa');

sgtitle('中心差分法') ;